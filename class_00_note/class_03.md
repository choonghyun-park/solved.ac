# class 3
solved.ac class 3 Essentials

## 다이나믹 프로그래밍
피보나치 수열을 재귀함수로 구현하면 아래와 같이 된다.
```py
def fibonacci(n):
    if n==0:
        return 0
    elif n==1:
        return 1
    else:
        return fibonacci(n-1) + fibonacci(n-2)
```
그런데, 문제에서 이렇게 재귀를 사용하면 시간초과가 난다. 위와 같은 재귀함수는 n이 커지면 연산 수행시간이 기하급수적으로 늘어난다. 질문게시판을 보니 다이나믹 프로그래밍을 사용해야 하는 문제라고 한다. \
다이나믹 프로그래밍은 `메모리 공간을 약간 더 사용`하여 연산속도를 비약적으로 증가시키는 방법이다. 한 번 수행한 연산의 결과를 메모리에 저장해 놓고 똑같은 연산의 결과가 필요하면 저장된 값을 다시 가져다 쓰는 개념이다. 메모리를 투자해서 연산속도를 증가시키는 방법인데, 이를 `메모제이션(캐싱) 기법`이라고도 한다.  \
1003.py 를 확인해보면, 0과 1을 카운팅하는 메모리 변수를 따로 만들어서 문제에서 요구하는 연산도 수행하도록 코드를 짜놨다. 기본적인 다이나믹 프로그래밍을 확인하기 위해서는 아래 피보나치 함수를 확인하면 된다.
```py
d = [0]*50
d[1] = 1

def fibonacci(n):
    if n==0:
        return 0
    elif n==1:
        return 1
    if d[n] != 0:
        return d[n]
    
    d[n] = fibonacci(n-1)+fibonacci(n-2)
    return d[n]
```

## 0으로 채워진 2차원 배열 
numpy를 이용하면 간단하게 0으로 채워진 2차원 배열을 만들 수 있다.
```py
import numpy as np

a = np.zeros((3,4))
```
그런데, 백준에서는 외부 라이브러리는 사용 못한다고 한다. numpy는 외부 라이브러리이므로 못써서, 다른 방법으로 0으로 채워진 list를 얻는 법을 알아봤다. 
### 0으로 채워진 1차원 배열 만들기
```py
list = [0 for i in range(10)]
# [0,0,0,0,0,0,0,0,0,0]
```
### 0으로 채워진 2차원 배열 만들기
변수 w는 width를, h는 height를 의미한다.
```py
double = [[0 for w in range(3)] for h in range(5)]
'''
[[0, 0, 0], 
 [0, 0, 0], 
 [0, 0, 0], 
 [0, 0, 0], 
 [0, 0, 0]]
'''
```